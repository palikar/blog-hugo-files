#+OPTIONS: ':t *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+OPTIONS: broken-links:nil c:nil creator:nil d:(not "LOGBOOK")
#+OPTIONS: date:t e:t email:nil f:t inline:t num:t p:nil pri:nil
#+OPTIONS: prop:nil stat:t tags:t tasks:t tex:t timestamp:t title:t
#+OPTIONS: toc:t todo:t |:t

#+TITLE: The optimal CMake project structure.
#+OPTIONS: ':nil -:nil ^:{} num:nil toc:nil
#+AUTHOR: Stanislav Arnaudov
#+DATE: <2019-04-10 Thu>
#+EMAIL: stanislav_ts@abv.bg
#+CREATOR: Emacs 26.1 (Org mode 9.2.1 + ox-hugo)
#+HUGO_FRONT_MATTER_FORMAT: toml
#+HUGO_LEVEL_OFFSET: 1
#+HUGO_PRESERVE_FILLING:
#+HUGO_SECTION: posts
#+HUGO_BASE_DIR: ~/code/blog-hugo-files/
#+HUGO_PREFER_HYPHEN_IN_TAGS: t 
#+HUGO_ALLOW_SPACES_IN_TAGS: nil
#+HUGO_AUTO_SET_LASTMOD: t
#+HUGO_DATE_FORMAT: %Y-%m-%dT%T%z
#+DESCRIPTION: Description of the project structure I intend to use in the future for my c++ projects.
#+HUGO_DRAFT: true
#+KEYWORDS: c++ cmake projects structure
#+HUGO_TAGS: 
 #+HUGO_CATEGORIES: c++
#+HUGO_WEIGHT: 100


* Abstract
I am sure that every C++ programmer has at one point stuggled with [[https://cmake.org/][CMake]]. There have been mulitple times where when I have to start work on some C++ project, I've spend a good couple of hours in thinking how should my project structure look like. It's just such a huge hassle to think about all of your CMakeList.txt files and possible libraries and diferent modules and... the things that may go wrong with your build system. I've been meaning to find a good template of a CMake project for a long time and now I think I've found\created my long wanted gem. In this post, I first want to give a brief overview of my past experience with CMake and the present the template project that I have finally settled with.


* The horrible past experience
I have bad memories in my erly days of dealing with CMake. At the start I had the impression that a build system should make everything as easy as possible but it seems that often this is not the case. Don't get me wrong. I know that build systems do not solve an easy problem, but still. I quickly noticed how there are a lot of people on the internet talking about their way of doing CMake projects. It didn't seem that there wasn't *the* way of doing it. This is generally a good thing. Freedom and doing things /your/ way! But everything comes with a cost. The cost of CMake -- you have no idea what you are supose to do at the beginning.

\\

My first experience with a big CMake project was while dealing with legacy code. The structure was similar to the one of [[https://github.com/opencv/openc][OpenCV]]. A big CMakeList.txt file at the top lever with general project settings, a separate file with all of the libraries needed for the project and then a src directory with different modules. Each module is in a folder of its own. The structure of a moudle: src, include, test, and data directory; a CMakeList.txt file a the root of the module to define all executables and libraries. I actually still like the structure of the individual modules. The strange thing with the module-system was the way it did dependeny resolution. Everything was done "manually". It essentially was a big CMake framework that first collected info about every module, looked at the dependencies between them and the needed libraries and then build targets manually for a module by linking explicitly everything that module needed. The whole thing was implemented in a collection of complicated macros. There maps and lists and algorithms and directory treversals and everything you can imagine. The whole thing written in CMake of course. Legacy code for the win!

\\

At one point I was considering building a similar system myself for my personal projects. Needless to say, that didn't take off. I wanted to clear up the structure and tightened it around the edges but I didn't have any form of success.

\\

I browsed some more CMake projects, I watched some talks (see [[https://www.youtube.com/watch?v=bsXLMQ6WgIk][Effective CMake]] Talk by [[https://github.com/purpleKarrot][Daniel Pfeifer]]) and I also tried setting up some thins myself. Nothing really clicked with me. CMake was still getting in the way of my C++ programming and it was making it even more painful than it already is. This went on for some while.


* The bright new world
Finally, a very fortunate thing happened. I watched [[https://www.youtube.com/watch?v=DHOlsEd0eDE][Applied Best Practices]] and decided to check out the [[https://github.com/lefticus/cpp_box][repository]]. The project is created with the idea of being a demonstation of "doing things properly" in C++. I can agree with this sentiment 100%! I still did some adjustements but I am still gratefull that I found this project. Here I will go over the elements of the structure of the template project that I created.

** Conan

[[https://conan.io/][Conan]] is one of the numerous attempts to bring the "package management world" to C++. Package management is one of those things that modern languages just "have by default" but somehow C++ hasn't exactly caught up. For by CMake structure I wanted at lest some attempt to make external dependency management a little bit easier. For this reason, I figured that Conan maybe a utility to start my experimentation with "C++ package management"

\\

From the Conan's website:
#+BEGIN_QUOTE
The open source, decentralized and multi-platform package manager to create and share all your native binaries.
#+END_QUOTE
I won' give (because I can't) a comprehensive guide on Conan here. I believe this here is just enough to set you up and give you some basic of how Conan does its magic.

\\
Conan can be installed through [[https://pypi.org/project/conan/][pip]] and there is an official [[https://docs.conan.io/en/latest/introduction.html][get started]] guide. Once everything is set up properly, you can write your ~conanfile.txt~ file in the root directory of your project. This is where all of your dependencies are defined. An example file is:

#+BEGIN_SRC conf
[requires]
        catch2/2.4.0@bincrafters/stable
        spdlog/1.3.1@bincrafters/stable
        fmt/5.3.0@bincrafters/stable
        rang/3.1.0@rang/stable
        clara/1.1.4@bincrafters/stable


[generators]
        cmake
        cmake_find_package
#+END_SRC
It is a /conf/ file with several sections. The dependencies go in the ~requires~ node. Usually what to put there is defined on the page of each Conan package. The ~generators~ section defines exactly what Conan does and how it builds the dependencies configuration files. Different generators have different effects and use cases. As we are dealing with a CMake project, the ~cmake~ and ~cmake_find_package~ are enough. With this configuration setup, you can later include several lines of CMake code in your top level CMakeLists.txt and just call ~find_package(...)~ for your dependencies. In theory at least. Sometimes things are a little bit tricky to get them running. If everything is as it is supposed to be, you can execute ~conan install <path_to_source_directory>~ in the build directory of the project and all of the dependencies will be fetched and saved in some cache on your machine.

\\

In my top level CMakeLists.txt, I have the following lines:
#+BEGIN_SRC cmake
# First a conan.cmake is downloaded, if not present. This files handles all of the "Conan"-y things with cmake... I guess.
if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
    message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
    file(DOWNLOAD  "https://raw.githubusercontent.com/conan-io/cmake-conan/master/conan.cmake"
        "${CMAKE_BINARY_DIR}/conan.cmake")
endif()
include(${CMAKE_BINARY_DIR}/conan.cmake)

# This is supposedly the minimal setup in CMake for Conan. After these lines everything should be ready to use
conan_check(REQUIRED)
conan_cmake_run(
    CONANFILE
    conanfile.txt
    BASIC_SETUP
    CONAN_COMMAND
    ${CONAN_CMD}
    CMAKE_TARGETS
    BUILD
    missing)
include(${CMAKE_BINARY_DIR}/conanbuildinfo.cmake) # conanbuildinfo.cmake is file generated by the cmake generator.
conan_basic_setup()
#+END_SRC

This sets up everything and at some later point I can just use something line:
#+BEGIN_SRC cmake
find_package(clara)
#+END_SRC
This includes all of the CMake targets defined for [[https://github.com/catchorg/Clara][Clara]]. We can later effortlessly link agings them when defining our executable for example.



** Top level CMakeList.txt

With Conan out of the way, I can now proceed to the pure CMake part of my project structure. At the start I want to lay out my key core design goals.
- Follow [[https://www.youtube.com/watch?v=bsXLMQ6WgIk][modern CMake guidelines]]
- Ease of use
- Modular setup
- Not worrying about dependencies between modules
- Support for testing
- Support for automatics documentation generation

\\

*** Folder structure
A high-level overview of the my project structure is as follows:
#+BEGIN_SRC sh
â”œâ”€â”€ cmake
â”‚Â Â  â”œâ”€â”€ FindGit.cmake
â”‚Â Â  â”œâ”€â”€ git_revision.cmake
â”‚Â Â  â””â”€â”€ safeguards.cmake
â”œâ”€â”€ doc
â”‚Â Â  â””â”€â”€ Doxyfile.in
â”œâ”€â”€ libs
â”‚Â Â  â””â”€â”€ CMakeLists.txt
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ module_1
â”‚Â Â  â”œâ”€â”€ module_2
â”‚Â Â  â””â”€â”€ CMakeLists.txt
â”œâ”€â”€ templates
â”‚Â Â  â”œâ”€â”€ template_app_module
â”‚Â Â  â””â”€â”€ template_lib_module
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ conanfile.txt
â”œâ”€â”€ create_new_app_module.sh
â”œâ”€â”€ create_new_lib_module.sh
â”œâ”€â”€ Doxyfile.in
â”œâ”€â”€ LICENSE
â”œâ”€â”€ Makefile
â””â”€â”€ README.md
#+END_SRC

Everything comes together in the top level CMakeLists.txt. This is the main entry point when running ~cmake <path_to_source_directory>~. In the ~cmake~ there are several utility CMake scripts that solve several small problems like finding the git version of the host machine and preventing me to build the project inside the source file tree. The ~Doxyfile.in~ file contains the basic configuration setup for [[http://www.doxygen.nl/][Doxygen]] which I use for generating documentation. My idea for the ~libs~ folder is to encapsulate the external dependencies that are not available through Conan. Of course, for some big dependencies (e.g. OpenCV) this is not really viable but it works like a charm for header only libraries. The ~libs/CMakeLists.txt~ is responsible for loading the libraries in the ~libs~ folder. The ~src~ directory houses all of the individual sub-modules in separate sub-folders that are included through the ~src/CMakeLists.txx~ script. More on the individual modules in a minute. In ~templates/~ I have a template visions of the two modules that the project can have -- a library or an executable. I want to add a new module to the project, I can use of the scrips at top level -- ~create_new_app_module.sh~ or ~create_new_lib_module.sh~ -- to generate the module easily. The ~create_new_app_module.sh~ looks like this:

#+BEGIN_SRC sh
# root directrory of the project
DIR=$(dirname "$(readlink -f "$0")")

MODULE_NAME=$1
# get the name of the project crom the CMakeLists.txt file
PROJECT_NAME=$(grep "project(\w*" CMakeLists.txt -o | grep "(.*" -o | cut -c 2-) 

if [ -d $DIR/${PROJECT_NAME}/${MODULE_NAME} ]; then
    echo "The module already exists"
    exit 1
fi

# copy the template module and rename its parts
cp -r $DIR/templates/template_app_module/ $DIR/src/
mv $DIR/src/template_app_module/ $DIR/src/${MODULE_NAME}
mv $DIR/src/${MODULE_NAME}/include/PROJECT/MODULE_NAME $DIR/src/${MODULE_NAME}/include/PROJECT/${MODULE_NAME}
mv $DIR/src/${MODULE_NAME}/include/PROJECT $DIR/src/${MODULE_NAME}/include/${PROJECT_NAME}

# expand 'MODULE_NAME' to the name of the module in every file of the module's folder
find $DIR/src/${MODULE_NAME} -type f -exec sed -i "s/MODULE_NAME/${MODULE_NAME}/g" {} \;
find $DIR/src/${MODULE_NAME} -type f -exec sed -i "s/PROJECT_NAME/${PROJECT_NAME}/g" {} \;

# add the module to the 'src/CMakeLists.txt' script
LINE="add_subdirectory(${MODULE_NAME})"
if [ ! $(grep $LINE $DIR/src/CMakeLists.txt) ]; then
    echo ${LINE} >> $DIR/src/CMakeLists.txt
fi
#+END_SRC

With this setup, I can simply execute ~./create_new_app_module.sh executable_1~ to add a new sub-module with the name "executable_1".

\\

The ~Makefile~ is there just so that I can automate some of the things I do on a regular basis in the project folder. Things like rebuilding, creating debug or release builds or cleaning all build folders.


*** Options
With the general folder structure, we can now go through several parts of the top level CMakeLists.txt script.

\\

Near the top of the script I have the options with which the project can be build. Those are just variables that can be true or false and enable certain conditions for the later parts of the scripts. The options are:

#+BEGIN_SRC cmake
option(ONLY_COVERAGE "Build only tests necessary for coverage" FALSE)
option(LIBCPP "Build with libc++" FALSE)
option(ENABLE_COVERAGE "Enable coverage reporting for gcc/clang" FALSE)
option(ENABLE_ASAN "Enable address sanitizer" FALSE)
option(BUILD_SHARED_LIBS "Enable compilation of shared libraries" FALSE)
option(ENABLE_TESTING "Enable the building of the test" FALSE)
option(ENABLE_CLANG_TIDY "Enable testing with clang-tidy" FALSE)
option(ENABLE_CPPCHECK "Enable testing with cppcheck" FALSE)
option(SIMPLE_BUILD "Build the project as minimally as possible" FALSE)
option(BUILD_DOC "Build the project's documentation" ON)
option(FORCE_COLORED_OUTPUT "Always produce ANSI-colored output (GNU/Clang only)." TRUE)
option(DEBUG_LOGGING "Enabling debug logging" FALSE)
#+END_SRC

I think the help strings are pretty self-explanatory so I won't go over each option individually. If you see any of these variables in later snippets, just know that it can be adjusted through the way the cmake is called when building the project. The options are passed as ~-D~ arguments to the cmake command. For example, to build with ~DEBUG_LOGGING~ enabled, we must call cmake like:
#+BEGIN_SRC sh
cmake .. -DDEBUG_LOGGING=TRUE
#+END_SRC


*** Targets
Modern CMake is all about targets! The general rule of thumb is not to touch any variable in CMake (like ~CMAKE_CXX_FLAGS~) directly but rather impose some requirements on a certain target. For the most part, the top level CMakeLists.txt follows this paradigm. Targets can be defines as INTERFACE. This means that they don't produce any build output (neither library, nor executable) but rather exist purely to be dependencies of other targets. Interface target can be used, for example, to "contain" compile options. When a executable target is defined and it links against one such interface target, all of the compiler options imposed on the interface, will also be imposed on the executable. This is the general idea that the CMakeLists.txt is structured around.

\\

At the start, there are two INTERFACE targets defined -- ~project_warnings~ and ~project_options~
#+BEGIN_SRC cmake
add_library(project_warnings INTERFACE)
add_library(project_options INTERFACE)
#+END_SRC

~project_warnings~ is meant to keep track of the flags that instruct the compiler on what warning to report on. ~project_options~ is for every other flag that may be passed to the compiler.


*** Flags
After the definition of the targets, there are several checks that decide on the compiler flags that are to be used. The significant parts of the "building" of the both targets are given in the next snippets.

\\
For starter, we make sure that we are programming in C++17. C++17 is as good as it gets and it's the current year so, of course, we are going to use it for every personal project.
#+BEGIN_SRC cmake
target_compile_features(project_options INTERFACE cxx_std_17)
#+END_SRC

If coverage is enabled for the build, we set the appropriate flags for the compiler. Notice how we are defining the options only on the targets and not in "global scope" through the [[https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_FLAGS.html#variable:CMAKE_%253CLANG%253E_FLAGS][CMAKE_CXX_FLAGS]] flag.
#+BEGIN_SRC cmake
if(ONLY_COVERAGE OR ENABLE_COVERAGE)
    target_compile_options(project_options INTERFACE --coverage -O0 -g)
    target_link_libraries(project_options INTERFACE --coverage)
endif()
#+END_SRC

We do something similar for the address sanitizers of the compiler:
#+BEGIN_SRC cmake
if(ENABLE_ASAN)
    target_compile_options(project_options INTERFACE -fsanitize=address)
    target_link_libraries(project_options INTERFACE -fsanitize=address)
endif()
#+END_SRC

While developing in C++, warnings are your friend. The more the better! Warnings can expose lots of tiny mistakes that you can make while writing C++ and in this sense, the compiler is your friend. As long as you tell it to report on the proper warning, of course.
#+BEGIN_SRC cmake
target_compile_options(project_warnings
    INTERFACE
    -Wall
    -Wextra
    -Wshadow
    -Wnon-virtual-dtor
    -Wold-style-cast
    -Wcast-align
    -Wunused
    -Woverloaded-virtual
    -Wpedantic
    -Wconversion
    -Wsign-conversion
    -Wnull-dereference
    -Wdouble-promotion
    -Wformat=2)

# some GCC specific warnings. Thiss flags are added onyl if the used compiler is GCC.
if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
    target_compile_options(project_warnings
        INTERFACE
        -Wmisleading-indentation
        -Wduplicated-cond
        -Wlogical-op
        -Wuseless-cast
        )
    target_link_libraries(project_options INTERFACE stdc++fs)
endif()

#+END_SRC

A colorful output on the terminal is alway useful. 
#+BEGIN_SRC cmake
if (${FORCE_COLORED_OUTPUT})
    if ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU")
        target_compile_options (project_options INTERFACE -fdiagnostics-color=always)
    elseif ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
        target_compile_options (project_options INTERFACE -fcolor-diagnostics)
    endif ()
endif ()
#+END_SRC

*** Extra tools
Other than the compiler flags, there are also several other external tools that can help you in your C++ development. Many of them can be integrated with CMake. In my project template, I have three of them.

\\

[[https://ccache.dev/][CCache]] is a compiler cache that speeds up recompilation. 
#+BEGIN_SRC cmake
find_program(CCACHE ccache)
if(CCACHE)
    set(CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE})
endif()
#+END_SRC

#+BEGIN_SRC cmake
if(ENABLE_CPPCHECK)
    find_program(CPPCHECK cppcheck)
    if(CPPCHECK)
	set(CMAKE_CXX_CPPCHECK
	    ${CPPCHECK}
	    --suppress=syntaxError
	    --enable=all
	    --inconclusive)
    else()
	message(SEND_ERROR "cppcheck requested but executable not found")
    endif()
endif()
#+END_SRC

#+BEGIN_SRC cmake
if(ENABLE_CLANG_TIDY)
    find_program(CLANGTIDY clang-tidy)
    if(CLANGTIDY)
	set(CMAKE_CXX_CLANG_TIDY ${CLANGTIDY})
    else()
	message(SEND_ERROR "clang-tidy requested but executable not found")
    endif()
endif()
#+END_SRC



*** Configurable header

** Modules





* Conclusion
So those are my two cents about CMake and project structure. I don't claim to have a lot of experience but I've done a lot of research in the past year and a half. I've looked into different projects, read the best practices, read a lot of vague tutorial on the internet and watched the relevant talks. I have though this several time, but _this_ time I really think I've nailed it. I hope that I've created (mostly stolen) something scalable that will server me well in my future small to mid size projects. Whether of not scalability should actually be of my concern is a completely separate matter ðŸ™‚. 


* References

- [1] [[https://github.com/lefticus/cpp_box][CPP_BOX]] is a project by [[https://github.com/lefticus][Jason Turner]].
- [2] [[https://vicrucann.github.io/tutorials/quick-cmake-doxygen/][Victoria Rudakova's Post]]
- [3] [[https://www.youtube.com/watch?v=bsXLMQ6WgIk][Effective CMake]] Talk by Daniel Pfeifer
- [4] [[https://www.youtube.com/watch?v=DHOlsEd0eDE][Applied Best Practices]] Talk by [[https://github.com/lefticus][Jason Turner]]



